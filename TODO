+ Refactor ast.c and give each operation its own proc, i.e. instead of huge
node_type switches call a corresponding procedure. Should help with debugging,
stack traces etc.

+ Add const and volatile attributes to types

+ Add const to procedures

+ Add external to procedures, essentially disables templates and name mangling,
to be used to interface with C

+ Come up with some better file extension, .cu seems to be used by cuda
	- In fact Copper is already taken :(

+ Build new type system (current one build on top of AST fucking sucks)
+ Build the consteval stuff
+ Use built in location tracking with @$ in bison?

+ For now it might be a good idea to just implement generic types to get
started, and add stuff like lambdas and so on later?

OPTIMIZATIONS:
+ Use hashmaps or something similar for lookups for types and calls
+ Output one procedure at a time through the backend, would allow us to free
actualized procs immediately instead of keeping them around in memory
+ Simplify IDs to just char arrays, would save on memory
+ Types can just be types, they maybe don't need to be full on AST nodes

LOWERING:

Structure handling in lowering could probably be as follows:

Imagine
struct something {
	i27 a;
	other_struct b;
};

main ()
{
	// something s = {...};
	i27 s_def = alloc $STRUCT_SIZE;
	// i27 a = s.a;
	i27 member_a = struct_def + 0;
	i27 a << struct_def 0;

	// other_struct c = s.b;
	i27 c_def = alloc $OTHER_STRUCT_SIZE;
	i27 member_b = struct_def + 3;
	c_def blit member_b, $OTHER_STRUCT_SIZE; // has to be added to qbt,
						 // might need to be handled
						 // like store with constant as
						 // 'return'. Or can c_def be
						 // considered an output value
						 // for blit?

	/* calls just dump all registers down I guess, as do returns. No
	 * implicit conversion to pointer and passed as first argument, ufcs
	 * does that for us. */
}
