/* String example */

pub struct string {
	len usize;
	buf *u8;
}

pub init(mut s *string)
{
	s.len = 0;
	s.buf = null;
}

pub deinit(mut s *string)
{
	dealloc(s.buf);
}

pub init(mut s *string, u *u8)
{
	len usize = 0;
	r any = u;
	while r++ {len++;}

	s.len = len;
	s.buf = alloc(s.len);
	memcpy(s.buf, u);
}

pub copy(mut r *string, s *string) *string
{
	dealloc(r.buf);
	r.len = s.len;
	r.buf = alloc(r.len);
	memcpy(r.buf, s.buf);
}

pub move(mut r *string, mut s *string) *string
{
	dealloc(r.buf);
	r.len = s.len;
	r.buf = s.buf;
	s.buf = null;
	s.len = 0;
}

pub length(s *string) usize
{
	return s.len;
}

pub index(s *string, i usize) u8
{
	assert(i < len, "index %zu out of bounds\n", i);
	return s.buf[i];
}

pub add(r *string, a *string, b *string)
{
	len any = length(a) + length(b);
	buf any = alloc(l);

	if r.buf == a.buf {
		dealloc(a.buf);
	} else if r.buf == b.buf {
		dealloc(b.buf);
	}

	r.buf = buf;
	r.len = len;
}

pub define new(x ...args)
{
	x = alloc(sizeof(x));
	init(@ ...args);
}

pub define ctx(x ...args)
{
	init(&x ...args);
	defer(deinit(@));
}

main(argc i32, argv [argc] * u8)
{
	something = argv[10]; // run type bounds checking for ranged array?
	// will not be automatically freed
	new(a *string);
	new(b *string, "hello");
	c string; // undefined state
	// will be automatically 'freed'
	ctx(c string);
	ctx(v vec<string>);
	append(v, a);
	append(v, c);
}
